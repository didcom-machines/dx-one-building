system-manager: imx95-var-dart: Power-off button support

Added support for graceful shutdown of the system via a dedicated
power-off button. Application cores keep powered off until a button press is detected.
Upon a new button press, while the system is running, it will initiate a graceful shutdown sequence.

Upstream-Status: Inappropriate [project-specific]
Signed-off-by: Manuel Monge <manuel.monge@didcom.com.mx>

diff --git a/configs/mx95evk/config_lmm.h b/configs/mx95evk/config_lmm.h
index 7a89fe8..6c2eff4 100755
--- a/configs/mx95evk/config_lmm.h
+++ b/configs/mx95evk/config_lmm.h
@@ -96,7 +96,8 @@
         .name = "AP", \
         .rpcType = SM_RPC_SCMI, \
         .rpcInst = 1U, \
-        .boot[0] = 3U, \
+        .autoBoot = LMM_AUTO_NONE, \
+        .boot[0] = 0U, /* Disables autoboot */ \
         .bootSkip[0] = 1U, \
         .start = 7U, \
         .stop = 7U, \
diff --git a/devices/MIMX95/sm/dev_sm_bbm.h b/devices/MIMX95/sm/dev_sm_bbm.h
index 24dc6be..b845819 100755
--- a/devices/MIMX95/sm/dev_sm_bbm.h
+++ b/devices/MIMX95/sm/dev_sm_bbm.h
@@ -101,6 +101,7 @@
 #define DEV_SM_BBM_BOOT_BUTTON    BIT32(1U)  /*!< Button power on */
 #define DEV_SM_BBM_BOOT_ALARM     BIT32(2U)  /*!< RTC alarm powered on */
 #define DEV_SM_BBM_BOOT_ROLLOVER  BIT32(3U)  /*!< RTC rollover powered on */
+#define DEV_SM_BBM_SHUTDOWN_BUTTON   BIT32(4U)  /*!< Button shutdown */
 /** @} */
 
 /* Types */
diff --git a/devices/simu/sm/dev_sm_bbm.h b/devices/simu/sm/dev_sm_bbm.h
index 24b9e59..98861bc 100755
--- a/devices/simu/sm/dev_sm_bbm.h
+++ b/devices/simu/sm/dev_sm_bbm.h
@@ -97,6 +97,7 @@
 #define DEV_SM_BBM_BOOT_BUTTON    BIT32(1U)  /*!< Button power on */
 #define DEV_SM_BBM_BOOT_ALARM     BIT32(2U)  /*!< RTC alarm powered on */
 #define DEV_SM_BBM_BOOT_ROLLOVER  BIT32(3U)  /*!< RTC rollover powered on */
+#define DEV_SM_BBM_SHUTDOWN_BUTTON   BIT32(4U)  /*!< Button shutdown */
 /** @} */
 
 /* Types */
diff --git a/sm/lmm/lmm_bbm.c b/sm/lmm/lmm_bbm.c
index 27d8c5d..a446527 100755
--- a/sm/lmm/lmm_bbm.c
+++ b/sm/lmm/lmm_bbm.c
@@ -263,28 +263,46 @@ void LMM_BbmRtcUpdateEvent(uint32_t rtcId)
 /*--------------------------------------------------------------------------*/
 void LMM_BbmButtonEvent(void)
 {
-    /* Dispatch for all LM */
-    for (uint32_t dstLm = 0U; dstLm < SM_NUM_LM; dstLm++)
+    uint32_t lmState = 0U;
+    int32_t errStatus = 0;
+    lmm_rpc_trigger_t trigger =
     {
-        lmm_rpc_trigger_t trigger =
-        {
-            .event = LMM_TRIGGER_BUTTON,
-        };
+        .event = LMM_TRIGGER_BUTTON,
+    };
 
-        /* Boot LM */
-        if ((g_lmmConfig[dstLm].autoBoot == LMM_AUTO_BUTTON)
-            || (g_lmmConfig[dstLm].autoBoot == LMM_AUTO_BOTH))
-        {
-            lmm_rst_rec_t bootRec = DEV_SM_RST_REC_BBM;
+    /* Get current state of LM2 (AP) */
+    (void) LM_SystemLmStatus(0U, 2U, &lmState, &errStatus);
+
+    /* Boot AP if currently off */
+    if (lmState == LMM_STATE_LM_OFF)
+    {
+        lmm_rst_rec_t bootRec = DEV_SM_RST_REC_BBM;
 
-            /* Reason is BBM button */
-            bootRec.errId = DEV_SM_BBM_BOOT_BUTTON;
-            bootRec.validErr = true;
+        /* Reason is BBM button */
+        bootRec.errId = DEV_SM_BBM_BOOT_BUTTON;
+        bootRec.validErr = true;
 
-            (void) LMM_SystemLmBoot(0U, 0U, dstLm, &bootRec);
-        }
+        (void) LMM_SystemLmBoot(0U, 0U, 2U, &bootRec);
+    }
+    /* Shutdown AP if currently running (graceful shutdown) */
+    else if (lmState == LMM_STATE_LM_ON)
+    {
+        lmm_rst_rec_t shutdownRec = DEV_SM_RST_REC_BBM;
+
+        /* Reason is BBM button */
+        shutdownRec.errId = DEV_SM_BBM_SHUTDOWN_BUTTON;
+        shutdownRec.validErr = true;
 
-        /* Send notification */
+        (void) LMM_SystemLmShutdown(0U, 0U, 2U, true, &shutdownRec);
+    }
+    else
+    {
+        ; /* AP in other state (suspend/powered), ignore */
+    }
+
+    /* Send notification to all LMs */
+    for (uint32_t dstLm = 0U; dstLm < SM_NUM_LM; dstLm++)
+    {
         (void) LMM_RpcNotificationTrigger(dstLm, &trigger);
     }
 }
